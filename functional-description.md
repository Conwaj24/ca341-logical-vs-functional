I chose to do the functional implementation in C, mostly because I wrote my imperative implementation in C and I figured it would be easy convert over to a functional style given that I usually write C in a functional style anyway. C is an interesting language for FP because it requires that you explicitly free up any memory to prevent leaks, which makes it more-or-less impossible to write code in a fully stateless way. On the other hand, because of how confusing code can become when you have to keep track of all the memory you've allocated, and because the function is the only from of abstraction the language has to offer, it is generally best practice to take on the lessons of functional programming when writing any C program.

Getting rid of all references to global state, and making sure that every function returned something were good low-hanging fruit to start with. But I soon realized that even though all of my functions returned a value, this value was not really any help, since the tree that is passed into the function is edited directly and what the function returns is just the same reference to the tree that was passed in. In short, my functions were having *side effects*. 

To tackle this problem, there were a number of changes I needed to make: Firstly, as I mentioned earlier, you can't write a program like this in C with an entirely functional style, because at some point you will have to deal with memory, but you can try to abstract all of that stuff away much like a functional *language* would do. This was the purpose of `core.c`. Core contains all of the stuff to do with memory; typedefs, allocation, and freeing. It also contains `fork` and `replace` which are the two functions upon which the whole functional aspect of this program depend on.

All `fork` does is return a copy of the given node, with the same value, but potentially different children if specified. It forks a node in more the version-control sense of the word than the kind of fork that a binary tree is made out of. When I add a node to a tree, the program creates forks of all nodes from the root down to where the leaf node is eventually added but, critically, leaves all other nodes that do not fall on that path intact, and then returns the new fork of the tree it has created. This, I believe, gives the program an elegance it would lack if I were to simply copy the entire tree each time, not to mention it's much lighter on resources. The final step is `replace` which frees all the nodes in the old tree that are not in the new one. It can be thought of as an assignment operator, for example; `tree = replace(tree, insert(x, tree))` assigns the value of the new tree to the old, and signals that the old tree is of no further use. I don't use `replace` anywhere in my program as I think it's better to delegate that responsibility to the caller.

The final change I made to the original was in cutting down on assignment operators wherever I could. Haskell has the `which` clause which helps you weasel out of having to actually assign a variable, however I had no such luxury. Still I think I did a thorough enough job and I think it shows just from looking at the code. Only `core.c` contains assignment and even there it's used sparingly.

In conclusion; while C wasn't the most obvious choice for FP, I'm glad it's the one I chose. I found that I had to think a lot more deeply about what functional programming is in a way I wouldn't have had I been using a language that does all of the policy-enforcement for me. As mentioned earlier; FP is usually a goal of good C code and, in that regard, I think I've learned a lot of practical knowledge about writing cleaner code from the excersize.