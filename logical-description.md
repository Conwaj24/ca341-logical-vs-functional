I chose Prolog for the logical side of the implementation because, unlike with functional-programming, I needed a specific type of language, and Prolog was the only such language I was familiar with. I often find it difficult to know where to start when writing Prolog; it's a much less linear language then most which makes it hard to simply *start at the beginning*, and it's very easy to end up with a circular dependency if you're not careful. Eventually I decided that the most sensible way of writing the program would be to play to Prolog's strengths and start by defining what a binary tree actually was. With a good definition, Prolog should just be able to magically pluck one out of the air for me if I declared that one should exist. I defined a binary tree as being an integer with no more than two children, one greater and one lesser.

After that I started on the endpoints as defined by the spec. Search was trivial as it relied on the `childOf` predicate I had already defined, insert was especially fiddly because I had to define a general case and a trivial case for both X < T and X > T. The order predicates (pre, post, in) are fairly elegant; they rely on boolean logic (which I believe is to be avoided in favor of predicates where possible) but it saves a lot of reiteration and I'm quite happy with how I defined the entire range of possibilities in a single predicate for each order (with recursion of course).